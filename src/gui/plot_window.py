# Change log
#
# 2025/05/06
# Considering change how the information of FigureWindow is managed. We should
# use a dictionary of dictionaries to hold key:info pair. The key should
# be a unique identifier/number generated by the PlotWindow class. The info
# dict should contain the information on the figure window, including the status
# of the figures. If the figures are closed, it will try to store the picture
# of the figures in different formats and release the fig instance/handle such
# that the memory of the pyplot figure can be released. The closed figure
# can be displayed and saved but not changed. The FigureWindow associated
# with each fig will be stored and when activated, will be notified
# to update the drawing and clickable items.
#
# 2025/05/03
# Clean up code to implement the following functions:
#   1. FigureWindow will show its cap with suptitle of the figure
#   2. FigureWindow will have different title color if the figure is the
#       current figure of plt
#   3. Use try-except-finally to address potential errors
#   4. PlotWindow do not actively change the current figure, but rather
#       just try to keep track of the active figure and update FigureWindow
#   5. Add figure management by name and fig_num

import logging
import random
import sys

import intercepts
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from PyQt6.QtCore import Qt, QMutex
from PyQt6.QtGui import QColor
from PyQt6.QtWidgets import (QApplication, QFileDialog, QListWidget,
                             QListWidgetItem, QMainWindow, QMenu, QMessageBox,
                             QTextEdit, QVBoxLayout, QWidget)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

logger = logging.getLogger(__file__ + "." + __name__)

class FigureWindow(QMainWindow):
    """This window class shows one figure as a separate window. When the user
    closes the figure window, the parent will be notified to keep track of the
    status of individual figures.

    Args:
        parent : 
            parent window that will receive notification when the user closes
            the figure window.
    """
    _figurewindow_mutex = QMutex()

    def __init__(self, fig: Figure, parent=None):
        super().__init__(parent)
        self.fig_ready = False
        try:
            self.redraw_fig(fig)
            self.fig_ready = True
        except Exception as e:
            logger.error("Error when initializing FigureWindow.")
            logger.exception(e, exc_info=True, stack_info=True)

    def redraw_fig(self, fig):
        if fig and fig.get_axes():
            self.fig = fig
            self.fig_num = fig.number
            self.fig_suptitle = fig.get_suptitle()

            self.canvas = FigureCanvas(fig)
            self.setCentralWidget(self.canvas)
            self.setWindowTitle(f"Figure {fig.number}")
            self.setGeometry(300, 300, 600, 400)

    def closeEvent(self, event):
        try:
            if self.fig_ready and self.parent() is not None:
                if hasattr(self.parent(), 'notify_figure_window_closed'):
                    self.parent().notify_figure_window_closed(self.fig.number)
        except Exception as e:
            logger.error("Error when FigureWindow try to invoke parent window notify_figure_window_closed() method.")
            logger.exception(e, exc_info=True, stack_info=True)
        finally:
            super().closeEvent(event)


def hook_figure_creation(*args, **kwargs):
    """
    This is the hook function to monitor the call to pyplot.figure() and maintain the figure list
    Args:
        *args:
        **kwargs:

    Returns:

    """
    facecolor = kwargs.pop('facecolor', None)
    edgecolor = kwargs.pop('edgecolor', None)
    frameon = kwargs.pop('frameon', True)
    FigureClass = kwargs.pop('FigureClass', matplotlib.figure.Figure)
    clear = kwargs.pop('clear', False)
    result = _(*args, facecolor=facecolor, edgecolor=edgecolor, frameon=frameon, FigureClass=FigureClass, clear=clear,
               **kwargs)
    PlotWindow._on_figure_created(result)
    return result


# --- PlotWindow: main plot manager window ---
class PlotWindow(QMainWindow):
    """This is the Matplotlib figure manager. Overall it will list the existing 
    matplotlib.pyplot figures, and display the info associated with each figure.
    For listed figures, if the figure has been closed by the function call 
    plt.close(), the status will be shown as (closed). Otherwise the figure
    will be marked as not closed. When clicking the figure that is not closed, 
    a call to plt.figure(fig_num) will be made such that the later call to 
    pyplot functions will modify this "active" figure.
    Double click the figure will bring up the figure as a separate window.
    In addition, the window provides save function to export the figure into 
    PNG, PDF or SVG formats.

    Args:
        parent : 
            give the parent object for this window.
        allow_full_close : 
            if True, when the user clicks the close button of the window,
            the window will be closed. Otherwise, the window will only
            hide and the parent/user can bring the window shown/active again
            later by calling the function show_window()        

    """
    _plotwindow_mutex = QMutex()
    figure_creation_hook = False
    _figure_uid: dict[int, Figure] = dict()
    _figure_track_list = dict()
    _instance = None
    _next_fig_uid = random.randint(1, 1000)

    def __init__(self, parent=None, allow_full_close=False):
        super().__init__(parent)

        if not self.figure_creation_hook:
            intercepts.register(plt.figure, hook_figure_creation)
            self.figure_creation_hook = True

        self.setWindowTitle("Plot Manager")
        self.setGeometry(100, 100, 400, 600)
        self.setWindowFlags(Qt.WindowType.Window | Qt.WindowType.WindowStaysOnTopHint)

        self.allow_full_close = allow_full_close

        self.list_widget = QListWidget()
        self.info_window = QTextEdit()
        self.info_window.setReadOnly(True)

        layout = QVBoxLayout()
        layout.addWidget(self.list_widget)
        layout.addWidget(self.info_window)

        main_widget = QWidget()
        main_widget.setLayout(layout)
        self.setCentralWidget(main_widget)

        self.list_widget.itemClicked.connect(self._on_figure_selected)
        self.list_widget.itemDoubleClicked.connect(self._on_figure_double_clicked)
        self.list_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self._open_context_menu)
        # Simple singleton pattern - warn if multiple instances
        if PlotWindow._instance is not None:
            logger.warning("Multiple PlotWindow instances detected. Using existing instance.")
            return
        PlotWindow._instance = self

    @classmethod
    def _check_fig_in_list(cls, fig: Figure) -> bool:
        return fig in cls._figure_uid.values()

    @classmethod
    def _get_fig_info_in_list(cls, fig: Figure) -> dict:
        for key, value in cls._figure_uid.items():
            if value == fig:
                return cls._figure_track_list.get(key, {})
        return {}

    @classmethod
    def _update_fig_info_in_list(cls, fig: Figure, **kwargs):
        for key, value in cls._figure_uid.items():
            if value == fig:
                if key in cls._figure_track_list:
                    cls._figure_track_list[key].update(kwargs)
                else:
                    cls._figure_track_list[key] = kwargs
                return
        unique_key = cls._next_fig_uid
        cls._next_fig_uid += 1

        cls._figure_uid[unique_key] = fig
        cls._figure_track_list[unique_key] = kwargs

    @staticmethod
    def _on_figure_created(fig: Figure):
        """
        This will be called by the hook function intercepting pyplot.figure().
        This functino will link the close_event for the figure to _on_figure_closed.
        Args:
            fig:

        Returns:

        """
        try:
            if fig is None:
                logger.error("Cannot monitor None figure")
                return
                
            if not PlotWindow._check_fig_in_list(fig):
                logger.info(f"Figure {fig.number} id({id(fig)}) has just been created or added to the list explicitly.")
                cid = fig.canvas.mpl_connect('close_event', PlotWindow._on_figure_closed)
                PlotWindow._update_fig_info_in_list(fig, **{'created': True, 'closed': False, 'close_event_cid': cid})
                if PlotWindow._instance:
                    PlotWindow._instance._update_fig_list()
        except Exception as e:
            logger.error("Error when monitoring figure creation")
            logger.exception(e, exc_info=True, stack_info=True)

    def notify_figure_window_closed(self, fig_num: int):
        """Notify that a figure window has been closed by the user."""
        try:
            for key, fig in self._figure_uid.items():
                if fig.number == fig_num:
                    fig_info = self._figure_track_list.get(key, {})
                    if 'figure_window' in fig_info:
                        del fig_info['figure_window']
                    break
            self._update_fig_list()
        except Exception as e:
            logger.error("Error when notifying figure window closed")
            logger.exception(e, exc_info=True, stack_info=True)

    @staticmethod
    def _on_figure_closed(event):
        try:
            fig = event.canvas.figure
            if PlotWindow._check_fig_in_list(fig):
                fig_info = PlotWindow._get_fig_info_in_list(fig)
                if 'close_event_cid' in fig_info:
                    fig.canvas.mpl_disconnect(fig_info['close_event_cid'])
                PlotWindow._update_fig_info_in_list(fig, **{'closed': True})
            else:
                logger.warning(f"Warning: fig {id(fig)} was not in the figure track list.")
            if PlotWindow._instance:
                PlotWindow._instance._update_fig_list()
            logger.info(f"Figure {fig.number} closed.")
        except Exception as e:
            logger.error("Error when monitoring figure closing")
            logger.exception(e, exc_info=True, stack_info=True)

    def _format_figure_name(self, fig: Figure, close_flag: bool) -> str:
        suptitle = fig.get_suptitle()
        if suptitle:
            figure_name = f"Figure {fig.number} ({suptitle})"
        else:
            figure_name = f"Figure {fig.number} (untitled)"
        if close_flag:
            figure_name += " (closed)"
        return figure_name

    def add_figure(self, fig: Figure):
        try:
            if fig is None:
                logger.error("Cannot add None figure")
                return
                
            self._on_figure_created(fig) #this will check the track list and add the figure if it is not in the list
            item = QListWidgetItem(self._format_figure_name(fig, False))
            item.setData(Qt.ItemDataRole.UserRole, fig)
            self.list_widget.addItem(item)
            self._update_fig_list()
        except Exception as e:
            logger.error("Error when adding figure")
            logger.exception(e, exc_info=True, stack_info=True)

    def _update_fig_list(self):
        try:
            for index in range(self.list_widget.count()):
                item = self.list_widget.item(index)
                fig = item.data(Qt.ItemDataRole.UserRole)
                if fig is not None and PlotWindow._check_fig_in_list(fig):
                    fig_info = PlotWindow._get_fig_info_in_list(fig)
                    close_flag = fig_info.get('closed', False)
                    fig_name = self._format_figure_name(fig, close_flag)
                    if fig is plt.gcf():
                        fig_name += "*"
                    item.setText(fig_name)
                    if close_flag:
                        item.setForeground(QColor("red"))
                    else:
                        item.setForeground(QColor("green"))
        except Exception as e:
            logger.error("Error when updating figure list")
            logger.exception(e, exc_info=True, stack_info=True)

    def _update_info_panel(self, fig: Figure):
        if fig is not None and PlotWindow._check_fig_in_list(fig):
            fig_num = fig.number
            fig_info = PlotWindow._get_fig_info_in_list(fig)
            close_status = fig_info.get('closed', False)
            text = f"""Figure {fig_num}\nAxes: {len(fig.get_axes())}\nClosed: {close_status}"""
            self.info_window.setText(text)

    def _on_figure_selected(self, item: QListWidgetItem):
        """
        Update info window, possibly update a thumbnail?
        Args:
            item:

        Returns:

        """
        fig = item.data(Qt.ItemDataRole.UserRole)
        if fig is not None:
            # Make the selected figure active
            plt.figure(fig.number)
            self._update_fig_list()
            self._update_info_panel(fig)

    def _on_figure_double_clicked(self, item: QListWidgetItem):
        fig = item.data(Qt.ItemDataRole.UserRole)
        if fig is not None:
            self.show_figure_window(fig)

    def _open_context_menu(self, position):
        menu = QMenu(self)
        # close_action = menu.addAction("Close Figure")
        save_action = menu.addAction("Save Figure")

        selected_item = self.list_widget.itemAt(position)
        if selected_item is None:
            return

        fig = selected_item.data(Qt.ItemDataRole.UserRole)
        if fig is None:
            return
            
        action = menu.exec(self.list_widget.mapToGlobal(position))

        if action is save_action:
            self._save_figure(fig)

    def _save_figure(self, fig: Figure):
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            f"Save Figure {fig.number}",
            f"figure_{fig.number}",
            "Images (*.png *.pdf *.svg)",
        )
        if file_path:
            if file_path.endswith(".pdf"):
                fig.savefig(file_path, format="pdf")
            elif file_path.endswith(".svg"):
                fig.savefig(file_path, format="svg")
            else:
                fig.savefig(file_path, format="png")

    def show_figure_window(self, fig: Figure):
        try:
            if fig is None:
                logger.error("Cannot show None figure")
                return
                
            if PlotWindow._check_fig_in_list(fig):
                fig_record = PlotWindow._get_fig_info_in_list(fig)
                if "figure_window" not in fig_record:
                    window = FigureWindow(fig, parent=self)
                    PlotWindow._update_fig_info_in_list(fig, **{"figure_window": window})
                    window.show()
                else:
                    window = fig_record["figure_window"]
                    if hasattr(window, 'isVisible') and window.isVisible():
                        window.showNormal()
                    else:
                        # Recreate window if it was closed
                        window = FigureWindow(fig, parent=self)
                        PlotWindow._update_fig_info_in_list(fig, **{"figure_window": window})
                        window.show()

                window.raise_()
                window.activateWindow()
        except Exception as e:
            logger.error("Error when showing figure window")
            logger.exception(e, exc_info=True, stack_info=True)

    def show_window(self):
        self.showNormal()
        self.raise_()
        self.activateWindow()

    def force_close_all(self):
        reply = QMessageBox.question(
            self,
            "Confirm Exit",
            "Are you sure you want to close Plot Manager and all figures?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )
        if reply == QMessageBox.StandardButton.Yes:
            # Close all matplotlib figures first
            # Close only the figures tracked by PlotWindow, not all matplotlib figures
            try:
                # Make a list of keys to avoid modifying the dict while iterating
                keys = list(PlotWindow._figure_track_list.keys())
                for key in keys:
                    fig_info = PlotWindow._figure_track_list.get(key, {})
                    # Close the associated matplotlib figure if it exists and is not already closed
                    fig = PlotWindow._figure_uid.get(key)
                    if fig is not None:
                        try:
                            plt.close(fig)
                        except Exception as e:
                            logger.error(f"Error closing matplotlib figure {fig}")
                            logger.exception(e, exc_info=True, stack_info=True)
                    # Close the associated figure window if it exists
                    if "figure_window" in fig_info:
                        try:
                            fig_info["figure_window"].close()
                        except Exception as e:
                            logger.error("Error closing figure window")
                            logger.exception(e, exc_info=True, stack_info=True)
            except Exception as e:
                logger.error("Error during force_close_all")
                logger.exception(e, exc_info=True, stack_info=True)
            
            # Clear list widget items to prevent memory leaks
            try:
                self.list_widget.clear()
            except Exception as e:
                logger.error("Error clearing list widget")
                logger.exception(e, exc_info=True, stack_info=True)
            
            # Clear tracking data
            self._figure_track_list.clear()
            self._figure_uid.clear()
            
            # Clear the singleton instance
            PlotWindow._instance = None
            
            self.close()

    def closeEvent(self, event):
        if self.allow_full_close:
            self.force_close_all()
        else:
            self.hide()
            event.ignore()


# --- Test Script ---
if __name__ == "__main__":
    app = QApplication(sys.argv)
    logging.basicConfig(level=logging.INFO)
    plot_window = PlotWindow(allow_full_close=True)
    plot_window.show()

    fig1 = plt.figure(1)
    x = np.linspace(0, 2 * np.pi, 100)
    plt.plot(x, np.sin(x))
    plot_window.add_figure(fig1)

    fig2 = plt.figure(2)
    plt.plot(x, np.cos(x))
    plot_window.add_figure(fig2)

    fig3 = plt.figure(3)
    plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
    plot_window.add_figure(fig3)

    plt.close(fig1)
    sys.exit(app.exec())
